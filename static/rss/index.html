<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Talal's Zone]]></title><description><![CDATA[Tech, Code and Ideas.]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Talal&apos;s Zone</title><link>http://localhost:2368/</link></image><generator>Ghost 5.26</generator><lastBuildDate>Mon, 26 Dec 2022 17:23:59 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Mooncake: A simplistic validation language]]></title><description><![CDATA[<p>Validating objects in code is an important part of almost every other project. Having gone through significantly large code bases where objects easily get more complex over time. The conventional validation methods can grow even more verbose, less scalable and maintainable.</p><p>The conventional methods usually comprise of several conditional checks,</p>]]></description><link>http://localhost:2368/mooncake/</link><guid isPermaLink="false">63a8dd8a6c1e0dc0f8f1b283</guid><dc:creator><![CDATA[Talal Ahmed]]></dc:creator><pubDate>Thu, 21 Jan 2021 23:32:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2022/12/maxresdefault.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2022/12/maxresdefault.jpeg" alt="Mooncake: A simplistic validation language"><p>Validating objects in code is an important part of almost every other project. Having gone through significantly large code bases where objects easily get more complex over time. The conventional validation methods can grow even more verbose, less scalable and maintainable.</p><p>The conventional methods usually comprise of several conditional checks, or perhaps a fancy framework on top using designs like method-chaining, schema validation etc. Looking at those tremendously huge code files with such verbose statements and checks. It only comes naturally to take the usual behaviour of conditionals and turn it into a simplistic language. The language may seem to be specific for a certain solution, but the idea is have it evolve over time while always keeping simplicity in mind.</p><p>Meet &quot;<strong><strong><a href="https://github.com/talal830/mooncake">Mooncake</a></strong></strong>&quot;, a descriptive yet less verbose validation language.</p><p>The name is inspired from the character <a href="http://final-space.wikia.com/wiki/Mooncake">Mooncake</a> in the tv-series <a href="https://en.wikipedia.org/wiki/Final_Space">Final Space</a>. Mooncake has a minimal vocabulary; yet he manages to convey his feelings conveniently...thus the inspiration :)</p><h2 id="how-it-works"><strong>How it works</strong></h2><p>The language is built with <a href="https://github.com/antlr/antlr4/blob/master/doc/go-target.md">Antlr</a> for Golang runtime. Antlr is a compiler-compiler which makes it easer to design and test languages.</p><p>Currently, objects in Json form can be handled, since behind the scene JsonPath is being used to locate attributes in objects. But this would eventually be replaced by language specific constructs e.g., Golang&apos;s structs using methods like reflection.</p><p>So to begin with, we need to compose rules that validate different fields/attributes of an object. A simplistic rule composition is as follows:</p><pre><code>item.id eq nil =&gt; [E0123, &apos;id can&apos;t be null&apos;]!!! # this causes fatal error
</code></pre><blockquote><em><em>This says:</em></em><br><em><em>if <em><em>expression:</em></em> <code>item.id eq nil</code> holds</em></em><br><em><em>then <em><em>implication:</em></em> <code>[E0123, &apos;id can&apos;t be null&apos;]!!!</code></em></em></blockquote><p>Breaking down further we have:</p><p><em><em>expression:</em></em></p><ul><li><code>item.id</code> -&gt; identifier (attribute path)</li><li><code>eq</code> -&gt; operator (equal)</li><li><code>nil</code> -&gt; literal (null)</li></ul><p><em><em>implication:</em></em></p><ul><li><code>E0123</code> -&gt; Error code</li><li><code>&apos;id can&apos;t be null&apos;</code> -&gt; Error message</li><li><code>!!!</code> -&gt; Error severity, here three exclamation marks mean Fatal</li><li><code># this causes ...</code> -&gt; Can be any statement related comment (not required)</li></ul><p>Now, lets see how a group of statements look like:</p><pre><code>item.id   eq nil =&gt; [E0123, &apos;id can&apos;t be null&apos;]!!!  # this is a fatal error
item.name eq nil =&gt; [E0124, &apos;name can&apos;t be null&apos;]!! # this is a severe error
item.addr eq nil =&gt; [E0125, &apos;addr can&apos;t be null&apos;]!  # this is a warning error
</code></pre><p>All simple and straightforward.</p><p>But what about statements which depend on each other? Example: <code>item.name eq nil</code> should be evaluated only if the expression <code>item.id eq nil</code> doesn&apos;t hold.</p><p>This can easily be done by appending <code>~</code> which allows linking of statements:</p><pre><code>~item.id   eq nil =&gt; [E0123, &apos;id can&apos;t be null&apos;]!!!  # fatal
~item.name eq nil =&gt; [E0124, &apos;name can&apos;t be null&apos;]!! # severe
~item.addr eq nil =&gt; [E0125, &apos;addr can&apos;t be null&apos;]!  # warning
</code></pre><p>So now all three statements depend on each other. The evaluation is done sequentially in order, which also allows for circuit-breaking.</p><p>Statements can also be grouped together in associated blocks. For example, a top level attribute <code>item</code> should always exist, in order to check all the remaining attributes:</p><pre><code>item eq nil =&gt; [E0122, &apos;item can&apos;t be null&apos;]!!!  # fatal
{
    ~item.id   eq nil =&gt; [E0123, &apos;id can&apos;t be null&apos;]!!!  # fatal
    ~item.name eq nil =&gt; [E0124, &apos;name can&apos;t be null&apos;]!! # severe
    ~item.addr eq nil =&gt; [E0125, &apos;addr can&apos;t be null&apos;]!  # warning
}
</code></pre><p>Infact another way of writing linked statements can be with blocks:</p><pre><code>item eq nil =&gt; [E0122, &apos;item can&apos;t be null&apos;]!!!  # fatal
{
    item.id eq nil =&gt; [E0123, &apos;id can&apos;t be null&apos;]!!!  # fatal
    {
        item.name eq nil =&gt; [E0124, &apos;name can&apos;t be null&apos;]!! # severe
        {
            item.addr eq nil =&gt; [E0125, &apos;addr can&apos;t be null&apos;]!  # warning   
        }
    }
}
</code></pre><p>Which is not so cool. Agreed!</p><p>So the blocks are more helpful when using declarations. More on this after functions.</p><p>Mooncake offers some built-in functions that can be applied to the identifiers and then checked with a literal within an expression.</p><p>Here&apos;s an example of a length(@len) function:</p><pre><code>@len item.list eq 0 =&gt; [E0126, &apos;list is empty&apos;]!! # severe
</code></pre><p>It could be the case that the calculated length has to be further filtered or reused in other statements. And so we have a useful case for declarations and blocks:</p><pre><code>_x @len item.list eq 0 =&gt; [E0126, &apos;list is empty&apos;]!! # severe
{
    _x lt 2 =&gt; [E0127, &apos;I&apos;d have loved more&apos;]! # warning
    
    _x gt ${ctx.threshold} =&gt; [E0128, &apos;Ok, that&apos;s way too much&apos;]! # warning
}
</code></pre><p>Here, a declaration <code>_x</code> holds the function <code>@len</code> value after applying to <code>item.list</code> identifier. Later on, inside the block, <code>_x</code> is used for validating some warnings.</p><p>The funny looking <code>${ctx.threshold}</code> literal, happens to reference a field in the <code>context struct</code>.</p><p>With <code>${...}</code> you have the ability to check against the referenced structures within the code that you pass to the <em><em>mooncake</em></em> executor.</p><p>Now that the rules are written and also executed (see <a href="https://github.com/talal830/mooncake">github</a> for execution details), we would have our result in a structure composing of arrays of all the fatals&apos;, severe&apos;s, warnings&apos; encountered during validation.</p><p>Pretty much like this:</p><pre><code>{
   &quot;Fatal&quot;:[
      {
         &quot;Code&quot;:&quot;E0122&quot;,
         &quot;Info&quot;:&quot;item is nil&quot;
      }
   ],
   &quot;Severe&quot;:[],
   &quot;Warning&quot;:[]
}

</code></pre><p>For the list of all operators, functions, errors and syntax related stuff please see the Readme on mooncake&apos;s repository: <a href="https://github.com/talal830/mooncake">https://github.com/talal830/mooncake</a></p><p>Let&apos;s see where it goes from here :)</p><hr>]]></content:encoded></item><item><title><![CDATA[Fixing Semantic Errors via Deep Learning]]></title><description><![CDATA[<p>writing in progress...</p><hr>]]></description><link>http://localhost:2368/fixing-semantic-errors-via-deep-learning/</link><guid isPermaLink="false">63a8f7966c1e0dc0f8f1b2ad</guid><category><![CDATA[DeepLearning]]></category><category><![CDATA[NLP]]></category><category><![CDATA[Semantic Errors]]></category><category><![CDATA[Code Fix]]></category><dc:creator><![CDATA[Talal Ahmed]]></dc:creator><pubDate>Sat, 19 Dec 2020 01:26:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2022/12/1_goFgCUHprcroxSLZvROjpg.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2022/12/1_goFgCUHprcroxSLZvROjpg.jpeg" alt="Fixing Semantic Errors via Deep Learning"><p>writing in progress...</p><hr>]]></content:encoded></item><item><title><![CDATA[Data Governance in Apache Spark using Apache Atlas]]></title><description><![CDATA[<p>writing in progress...</p><hr>]]></description><link>http://localhost:2368/data-governance/</link><guid isPermaLink="false">63a8f6036c1e0dc0f8f1b2a1</guid><dc:creator><![CDATA[Talal Ahmed]]></dc:creator><pubDate>Thu, 10 Dec 2020 01:17:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2022/12/data-governance.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2022/12/data-governance.png" alt="Data Governance in Apache Spark using Apache Atlas"><p>writing in progress...</p><hr>]]></content:encoded></item><item><title><![CDATA[Using Software Product Lines (SPL) in Gaming Backends]]></title><description><![CDATA[<p>writing in progress...</p><hr>]]></description><link>http://localhost:2368/using-software-product-lines-spl-in-gaming-backends/</link><guid isPermaLink="false">63a8f8a16c1e0dc0f8f1b2b9</guid><dc:creator><![CDATA[Talal Ahmed]]></dc:creator><pubDate>Mon, 30 Nov 2020 01:28:00 GMT</pubDate><content:encoded><![CDATA[<p>writing in progress...</p><hr>]]></content:encoded></item></channel></rss>